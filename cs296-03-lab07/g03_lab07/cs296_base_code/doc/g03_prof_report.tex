\documentclass[11pt]{article}
\usepackage{times}
\usepackage{graphicx}
\usepackage[top=1.0in,bottom=1.0in,left=0.5in,right=0.5in]{geometry}
\usepackage{url}

\begin{document}
\bibliographystyle{plain}%Choose a bibliograhpic style
\title{A CS296 Report on Timing and Profiling by Group 03.}
\date{\today}
\author{Anurag Shirolkar \\ (120050003) \\ anuragshirolkar@cse.iitb.ac.in
        \and Deepanjan Kundu \\ (120050009) \\ deepanjan@cse.iitb.ac.in
        \and Syamantak Naskar \\ (120050016) \\ syamantaknaskar@cse.iitb.ac.in}
\maketitle
\section{INTRODUCTION}
The Report describes the observations and inferences from various Timing and Profiling experiments.The main topics seen are:
\begin{itemize}
\item Inferences we get from Timing graphs
\item Observation and comparison of profile report
\item Study of the call graphs
\end{itemize}
\section{TIMING}
The conclusions have been made using first three graphs which coveres variation of all kinds of time variables with iteration value.
The graphs have been generated by using a graph generated for iteration value=1500 and 10 reruns.
\subsection{LOOP TIME}
\begin{center}
  \includegraphics[scale=.5]{g03_plot01.png}
\end{center}
The loop time describes the time taken by the for loop to run. From the above graph one can conclude that it varies linearly with the iteration value as expected from the system.The for loop time which has been considered is the total for loop time over all the iterations and hence is larger than even the step time.The graph 1 clearly shows that step time graph lies very close to the zero value.
\subsection{COLLISION,VELOCITY and  other timings} 
\begin{center}
  \includegraphics[scale=0.75]{g03_plot02.png}
\end{center}
The observations and inferences made are :
\begin{itemize}
\item Step time is largest among the collision,velocity ,position times.The order is Steptime is greater than sum of the average collision,velocity and position time is greater than average velocity time.However the average collision and position time are very close to each other.
\item There is a variation in the nature of graph as well.For small iteration values all the different types of times decrease andthe n reaching a minimumrises and then becomes fairly constant.
\item The inference that could have been drawn is that initially the number of moving objects are close to zero and we need to fix all the different parameters.However later we could recursively find the values and the number of moving objectsis the same,hence decreasing the time.However the no. of moving objects increase later(like falling of dominoes and balls)  and hence we see a slight increase in the graph which later becomes constant as the parameters are easily found and moving objects are also constant. 
\end{itemize}
\subsection{Variation in time over reruns}
\begin{center}
  \includegraphics[scale=.75]{g03_plot03.png}
\end{center}
The error bars in graph clearly show that there is variation in running time in different reruns.This is primarily due to the different  processes running through out the system.
\subsection{EFFECT OF MEMORY HEAVY AND CPU HEAVY PROCESSES}
This time largely depends on the nuber of cores in the system .The observation have been made on the basis of the NSL systems.
Effect of memory and cpu extensive processes(Games and libre office and several other programs and cpying and downloading processes.)
We expected that the system would slow down.However CPU processes didnot affect the timings as much the memory heavy processes .For small iteration values the change is almost nothing but the difference is a little evident at high values like 1500.The differences are not visible in graph as differences are of few milliseconds for the total loop time.\\
This happened because we were not able  to reach complete cpu usage.
However the point to note is that given complete Cpu usage the program will take a lot of time for running(about 40 percent).How ever if we are not able to push to those limits then only memory processes have some effect. 
\subsection{DIFFERENCE BETWEEN TIME AND GET TIME OF DAY}
\begin{center}
Number of iterations: 10000\\
Average time per step is 1.0400 ms\\
Average time for collision is 0.0610 ms\\
Average time for velocity updates is 0.2190 ms\\
Average time for position updates is 0.0760 ms\\
Total loop time is 1018.3280 ms\\
real	0m1.023s\\
user	0m1.016s\\
sys	0m0.004s
\end{center}
Time has three types:real,user and system.Time we need to see is user time.This time covers(time for user code processes) the entire time from the start of the program to the end  and  gettimeofday  just calculates the difference between the starting and end times of the for loop.Hence the time taken by the time command is greater than get time of day. 
\section{PROFILING}
The profile shows which function is called from where and what percentage of the time it uses.
This part covers both type of profiling using debug and release type of builds.
Perf has been used to generate the profiles.The profile info is stored in the form of .dat files.
\subsection{DEBUG vs RELEASE}
Debug and release are both different types of builds,hence we use different cmake commands for both of them.Also release has a lesser running time than debug.This happens because  of the -On option which helps in internal optimizing.What it does is inline function calls and hence reduces the time.How ever the compilation time  of debug  is less than release.There is also significant difference 
Release Profile has lesser number of calls as compared to  Debug profile in the graph because of optimization.
\subsection{DEBUG PROFILING REPORT}
Debug profile report has about 2Kcycles for 10000 iterations.The maximum overhead is taken for the symbol 0x2d6e4.This covers about 10\% of the time.The operator like +,*,- and functions like b2Contactsolver and b2 Vec2 consume 
a significant time.
\begin{center}
  \includegraphics[scale=.25]{debug.png}
\end{center}
\subsection{RELEASE PROFILING REPORT}
Release profile report shows 1K cycles for 10000 iterations. The maximum overhead is taken for the symbol 0x2d67e.It uses a shared library and occupies 30\% of the time.
The operators like +,* consume a lot of time and functions like b2 Contact solver consumes about 11\% time.
\begin{center}
  \includegraphics[scale=.3]{release.png}
\end{center}
\subsection{CALLGRAPHS}
Call graph,a graph showing the callee-caller relationship between functions, annotated with different information on the edges has also been generated from a python script.\\
The graph has arrows representing percentages and color represents how much \% of time that function uses.

\subsubsection{DEBUG}
CALL-GRAPH FOR DEBUG PROFILE:
\begin{center}
  \includegraphics[scale=.07]{output_d.png}
\end{center}
The debug profile is generated for suggestions concerned with debugging.
The debug profile generated by perf is quite well explained and contains a lot of calls.The profile shows that most of the time about 90 \% is consumed in the \texttt{base\_sim\_t} class.Out of this about 20 \% is consumed in Debug draw and  about seventy "\%" is consumed in the World generation which is also mainly concerned with functions solving for positions ,velocities and other parameters.   
\subsubsection{RELEASE}
CALL-GRAPH FOR RELEASE PROFILE:
\begin{center}
  \includegraphics[scale=.06]{output_r.png}
\end{center}
The release profile uses the -On tags which help in internal optimizing.
The release profile generated by perf has relatively less calls.In this graph most of the time is used in call to the Draw shape function which inturn calls to DebugDraw functions.It has calls to solveVelocityConstraints and such functions but the percentage time is relatively less.The time within this  is also heavily consumed by the operators.
\subsection{OPTIMIZING}
The parts of the programs to be optimized are the ones  are the ones which consume more percentage of time(Some of them have been listed in descriptions like +,*,- operators and functions like b2Contactsolver and b2 Vec2) and which debug does but release optimizes. \\
We could also try to optimize those functions which took time in both release and debug profile and the -On tag wasn't able to optimize them.

\end{document}
